import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { useLocation, useNavigate, useParams } from 'react-router-dom';
import TopBar from '@/components/layout/TopBar';
import ServicePalette from '@/components/layout/ServicePalette';
import DiagramCanvas from '@/components/layout/DiagramCanvas';
import InspectorPanel from '@/components/layout/InspectorPanel';
import JobsDrawer from '@/components/layout/JobsDrawer';
import ChatPanel from '@/components/layout/ChatPanel';
import AssetManager from '@/components/layout/AssetManager';
import IaCVisualization from '@/components/layout/IaCVisualization';
import { ResizableDivider } from '@/components/ui/resizable-divider';
import { useDiagramStore } from '@/store/diagramStore';
import { generateIac, createDeployment } from '@/lib/api';
import DeployModal from '@/components/layout/DeployModal';
import { useToast } from '@/hooks/use-toast';
import { useSupabase } from '@/context/SupabaseContext';
import { getProjectById, saveProjectDiagramState, updateProjectTitle, deleteProject, updateProjectIacTemplates, type ProjectDiagramState } from '@/services/projectService';
import { useIacStore } from '@/store/iacStore';

interface IaCFile {
  id: string;
  name: string;
  type: 'bicep' | 'terraform' | 'arm' | 'yaml';
  content: string;
  size: number;
  status: 'generated' | 'validated' | 'error';
  errors?: string[];
  warnings?: string[];
  parameters?: Record<string, unknown>;
  autoGenerated?: boolean;
}

const seedFiles: IaCFile[] = [];

type LocationState = {
  initialPrompt?: string;
  projectId?: string;
  openChat?: boolean;
} | null;

const Workspace = () => {
  const { projectId: routeProjectId } = useParams<{ projectId?: string }>();
  const location = useLocation();
  const navigate = useNavigate();
  const [isChatOpen, setIsChatOpen] = useState(false);
  const [isAssetsOpen, setIsAssetsOpen] = useState(false);
  const [isIacOpen, setIsIacOpen] = useState(false);
  const [pendingPrompt, setPendingPrompt] = useState<string | null>(null);
  const [projectId, setProjectId] = useState<string | undefined>(routeProjectId);
  const [projectTitle, setProjectTitle] = useState<string | undefined>(undefined);
  const [footerHeight, setFooterHeight] = useState<number>(192); // Default: 192px (h-48)
  const [isInspectorCollapsed, setIsInspectorCollapsed] = useState<boolean>(false);
  const [isServicePaletteCollapsed, setIsServicePaletteCollapsed] = useState<boolean>(false);

  const { client: supabaseClient, supabaseAvailable } = useSupabase();
  const { nodes, edges, clearDiagram, replaceDiagram, loadDiagram } = useDiagramStore();
  const { toast } = useToast();

  const locationState = location.state as LocationState;

  const [generatedFiles, setGeneratedFiles] = useState<IaCFile[]>(seedFiles);
  const [deployingFile, setDeployingFile] = useState<IaCFile | null>(null);
  const [isDeployModalOpen, setIsDeployModalOpen] = useState(false);

  const setBicepTemplate = useIacStore((state) => state.setBicepTemplate);
  const clearIacStore = useIacStore((state) => state.clear);
  const pendingBicepTemplate = useIacStore((state) => state.pendingBicepTemplateUpdate);
  const consumePendingBicepTemplate = useIacStore((state) => state.consumePendingBicepTemplate);

  const lastAiSyncRef = useRef<number>(0);
  const autoIacTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const pendingSignatureRef = useRef<string | null>(null);
  const lastSuccessfulSignatureRef = useRef<string | null>(null);
  const latestDiagramSignatureRef = useRef<string>('');
  const autoIacRunningRef = useRef(false);

  const persistIacArtifacts = useCallback(
    async (artifacts: {
      bicep?: { template: string; parameters?: Record<string, unknown> | null };
      terraform?: { template: string; parameters?: Record<string, unknown> | null };
    }) => {
      if (!artifacts.bicep?.template && !artifacts.terraform?.template) {
        return;
      }

      setGeneratedFiles((prev) => {
        let next = [...prev];

        if (artifacts.bicep?.template) {
          next = next.filter((file) => !(file.autoGenerated && file.type === 'bicep'));
          next = [
            ...next,
            {
              id: 'auto-bicep',
              name: 'auto-generated.bicep',
              type: 'bicep',
              content: artifacts.bicep.template,
              size: artifacts.bicep.template.length,
              status: 'generated',
              autoGenerated: true,
              parameters: artifacts.bicep.parameters ?? undefined,
            },
          ];
        }

        if (artifacts.terraform?.template) {
          next = next.filter((file) => !(file.autoGenerated && file.type === 'terraform'));
          next = [
            ...next,
            {
              id: 'auto-terraform',
              name: 'auto-generated.tf',
              type: 'terraform',
              content: artifacts.terraform.template,
              size: artifacts.terraform.template.length,
              status: 'generated',
              autoGenerated: true,
              parameters: artifacts.terraform.parameters ?? undefined,
            },
          ];
        }

        return next;
      });

      if (projectId && supabaseClient) {
        const payload: Parameters<typeof updateProjectIacTemplates>[2] = {};
        if (artifacts.bicep?.template) {
          payload.bicepTemplate = artifacts.bicep.template;
          if ('parameters' in artifacts.bicep) {
            payload.bicepParameters = artifacts.bicep.parameters ?? null;
          }
        }
        if (artifacts.terraform?.template) {
          payload.terraformTemplate = artifacts.terraform.template;
          if ('parameters' in artifacts.terraform) {
            payload.terraformParameters = artifacts.terraform.parameters ?? null;
          }
        }

        if (Object.keys(payload).length > 0) {
          try {
            await updateProjectIacTemplates(supabaseClient, projectId, payload);
          } catch (error) {
            console.error('[Workspace] Failed to persist IaC templates', error);
          }
        }
      }

      lastAiSyncRef.current = Date.now();
      lastSuccessfulSignatureRef.current = latestDiagramSignatureRef.current;

        if (artifacts.bicep?.template) {
          setBicepTemplate(artifacts.bicep.template);
        } else {
          clearIacStore();
        }
    },
    [clearIacStore, projectId, setBicepTemplate, supabaseClient]
  );

  const diagramSignature = useMemo(() => {
    const nodeSignature = nodes.map((node) => ({
      id: node.id,
      position: node.position,
      parentNode:
        (node as Record<string, unknown>).parentNode ?? (node as Record<string, unknown>).parentId ?? null,
    }));
    const edgeSignature = edges.map((edge) => ({
      id: edge.id,
      source: edge.source,
      target: edge.target,
      label: edge.label ?? null,
    }));
    return JSON.stringify({ nodes: nodeSignature, edges: edgeSignature });
  }, [nodes, edges]);

  useEffect(() => {
    latestDiagramSignatureRef.current = diagramSignature;
  }, [diagramSignature]);

  useEffect(() => {
    pendingSignatureRef.current = null;
    lastSuccessfulSignatureRef.current = null;
  }, [projectId]);

  const runAutoIac = useCallback(
    async (signature: string) => {
      if (!projectId || !supabaseClient || !supabaseAvailable) {
        return;
      }

      const { nodes: latestNodes, edges: latestEdges } = useDiagramStore.getState();
      if (!latestNodes.length) {
        pendingSignatureRef.current = null;
        return;
      }

      autoIacRunningRef.current = true;
      try {
        const bicepResp = await generateIac({ nodes: latestNodes, edges: latestEdges }, 'bicep');
        let terraformResp: Awaited<ReturnType<typeof generateIac>> | null = null;
        try {
          terraformResp = await generateIac({ nodes: latestNodes, edges: latestEdges }, 'terraform');
        } catch (terraformError) {
          console.warn('[Workspace] Auto Terraform regeneration failed', terraformError);
        }

        const bicepTemplateCandidate =
          (bicepResp && typeof bicepResp.content === 'string' && bicepResp.content) ||
          (bicepResp && typeof (bicepResp as Record<string, unknown>).bicep_code === 'string'
            ? ((bicepResp as Record<string, unknown>).bicep_code as string)
            : '');
        const terraformTemplateCandidate =
          terraformResp && typeof terraformResp.content === 'string' && terraformResp.content
            ? terraformResp.content
            : terraformResp &&
              typeof (terraformResp as Record<string, unknown>).terraform_code === 'string'
            ? ((terraformResp as Record<string, unknown>).terraform_code as string)
            : '';

        const artifacts = {
          bicep:
            typeof bicepTemplateCandidate === 'string' && bicepTemplateCandidate.trim().length > 0
              ? {
                  template: bicepTemplateCandidate.trim(),
                  parameters:
                    bicepResp.parameters && typeof bicepResp.parameters === 'object'
                      ? (bicepResp.parameters as Record<string, unknown>)
                      : null,
                }
              : undefined,
          terraform:
            typeof terraformTemplateCandidate === 'string' && terraformTemplateCandidate.trim().length > 0
              ? {
                  template: terraformTemplateCandidate.trim(),
                  parameters:
                    terraformResp.parameters && typeof terraformResp.parameters === 'object'
                      ? (terraformResp.parameters as Record<string, unknown>)
                      : null,
                }
              : undefined,
        };

        if (artifacts.bicep || artifacts.terraform) {
          await persistIacArtifacts(artifacts);
          console.log('[Workspace] Auto IaC regeneration completed');
        }
        lastSuccessfulSignatureRef.current = signature;
      } catch (error) {
        console.error('[Workspace] Auto IaC regeneration failed', error);
      } finally {
        autoIacRunningRef.current = false;
        if (pendingSignatureRef.current === signature) {
          pendingSignatureRef.current = null;
        }
      }
    },
    [persistIacArtifacts, projectId, supabaseAvailable, supabaseClient]
  );

  useEffect(() => {
    if (!projectId || !supabaseClient || !supabaseAvailable) {
      return;
    }
    if (!diagramSignature) {
      return;
    }

    if (lastSuccessfulSignatureRef.current === null) {
      lastSuccessfulSignatureRef.current = diagramSignature;
      return;
    }

    if (
      diagramSignature === lastSuccessfulSignatureRef.current ||
      diagramSignature === pendingSignatureRef.current
    ) {
      return;
    }

    if (Date.now() - lastAiSyncRef.current < 4000) {
      lastSuccessfulSignatureRef.current = diagramSignature;
      return;
    }

    if (autoIacTimerRef.current) {
      clearTimeout(autoIacTimerRef.current);
    }

    const schedule = () => {
      if (autoIacRunningRef.current) {
        autoIacTimerRef.current = setTimeout(schedule, 1000);
        return;
      }
      autoIacTimerRef.current = null;
      pendingSignatureRef.current = diagramSignature;
      void runAutoIac(diagramSignature);
    };

    autoIacTimerRef.current = setTimeout(schedule, 2000);

    return () => {
      if (autoIacTimerRef.current) {
        clearTimeout(autoIacTimerRef.current);
        autoIacTimerRef.current = null;
      }
    };
  }, [diagramSignature, projectId, runAutoIac, supabaseAvailable, supabaseClient]);
  useEffect(() => {
    if (!locationState) {
      return;
    }

    if (locationState.projectId) {
      setProjectId(locationState.projectId);
    }

    if (locationState.initialPrompt) {
      setPendingPrompt(locationState.initialPrompt);
      setIsChatOpen(true);
    } else if (locationState.openChat) {
      setIsChatOpen(true);
    }

    navigate(location.pathname, { replace: true, state: null });
  }, [location.pathname, locationState, navigate]);

  useEffect(() => {
    setProjectId(routeProjectId);
    clearIacStore();
  }, [clearIacStore, routeProjectId]);

  useEffect(() => {
    clearDiagram();
    setGeneratedFiles([]);
  }, [clearDiagram, projectId]);

  useEffect(() => {
    if (!projectId || !supabaseAvailable || !supabaseClient) {
      return;
    }
    let cancelled = false;
    (async () => {
      try {
        const project = await getProjectById(supabaseClient, projectId);
        if (cancelled) {
          return;
        }
        const diagram = project.diagram_state as ProjectDiagramState | null;
        // capture title so TopBar can show/edit it
        setProjectTitle(project?.title ?? undefined);
        if (diagram && Array.isArray(diagram.nodes) && Array.isArray(diagram.edges)) {
          loadDiagram(diagram.nodes, diagram.edges);
          console.log('[Workspace] Loaded persisted diagram state', {
            projectId,
            nodeCount: diagram.nodes.length,
            edgeCount: diagram.edges.length,
          });
        }

        const autoFiles: IaCFile[] = [];
        if (project?.bicep_template) {
          autoFiles.push({
            id: 'auto-bicep',
            name: 'auto-generated.bicep',
            type: 'bicep',
            content: project.bicep_template,
            size: project.bicep_template.length,
            status: 'generated',
            autoGenerated: true,
            parameters: project.bicep_parameters ?? undefined,
          });
          setBicepTemplate(project.bicep_template);
        } else {
          clearIacStore();
        }
        if (project?.terraform_template) {
          autoFiles.push({
            id: 'auto-terraform',
            name: 'auto-generated.tf',
            type: 'terraform',
            content: project.terraform_template,
            size: project.terraform_template.length,
            status: 'generated',
            autoGenerated: true,
            parameters: project.terraform_parameters ?? undefined,
          });
        }
        if (autoFiles.length) {
          setGeneratedFiles(autoFiles);
          lastAiSyncRef.current = Date.now();
        }
      } catch (error) {
        console.error('[Workspace] Failed to load diagram state', error);
      }
    })();
    return () => {
      cancelled = true;
    };
  }, [projectId, supabaseAvailable, supabaseClient, loadDiagram, setBicepTemplate, clearIacStore]);

  useEffect(() => {
    if (!pendingBicepTemplate) {
      return;
    }
    const template = consumePendingBicepTemplate();
    if (!template) {
      return;
    }

    setGeneratedFiles((prev) => {
      const next = [...prev];
      const existingIndex = next.findIndex((file) => file.id === 'auto-bicep');
      if (existingIndex >= 0) {
        next[existingIndex] = {
          ...next[existingIndex],
          content: template,
          size: template.length,
        };
      } else {
        next.unshift({
          id: 'auto-bicep',
          name: 'auto-generated.bicep',
          type: 'bicep',
          content: template,
          size: template.length,
          status: 'generated',
          autoGenerated: true,
        });
      }
      return next;
    });

    (async () => {
      if (!projectId || !supabaseClient || !supabaseAvailable) {
        return;
      }
      try {
        await updateProjectIacTemplates(supabaseClient, projectId, {
          bicepTemplate: template,
        });
      } catch (error) {
        console.error('[Workspace] Failed to persist edited Bicep template', error);
      }
    })();
  }, [
    consumePendingBicepTemplate,
    pendingBicepTemplate,
    projectId,
    supabaseAvailable,
    supabaseClient,
  ]);

  const handleChatToggle = () => {
    setIsChatOpen((prev) => !prev);
  };

  const handleAssetsToggle = () => {
    setIsAssetsOpen((prev) => !prev);
  };

  const handleIacToggle = () => {
    setIsIacOpen((prev) => !prev);
  };

  const handleSave = async () => {
    if (!projectId || !supabaseClient) {
      toast({
        title: "Cannot Save",
        description: "Please sign in and create a project to save your diagram.",
        variant: "destructive",
      });
      return;
    }

    try {
      const payload: ProjectDiagramState = {
        nodes,
        edges,
        saved_at: new Date().toISOString(),
      };
      
      await saveProjectDiagramState(supabaseClient, projectId, payload);
      
      toast({
        title: "Diagram Saved",
        description: `Saved ${nodes.length} nodes and ${edges.length} connections.`,
      });
    } catch (error) {
      console.error('Failed to save diagram:', error);
      toast({
        title: "Save Failed",
        description: "Failed to save diagram. Please try again.",
        variant: "destructive",
      });
    }
  };

  const handleGenerate = async (
    type: 'bicep' | 'terraform',
    options?: { providerVersion?: string; workspace?: string; namingConvention?: string }
  ) => {
    try {
      const diagramData = { nodes, edges };
      const resp = await generateIac(diagramData, type, options);
      const code: string = resp.content || '';
      const format: string = resp.format || type;
      const isBicep = format === 'bicep';
      const fileName = `diagram-${new Date().toISOString().replace(/[:.]/g, '-')}.${isBicep ? 'bicep' : format === 'terraform' ? 'tf' : format}`;
      const sanitized = code.trim();
      const newFile: IaCFile = {
        id: crypto.randomUUID(),
        name: fileName,
        type: isBicep ? 'bicep' : format === 'terraform' ? 'terraform' : 'bicep',
        content: sanitized,
        size: sanitized.length,
        status: 'generated',
        warnings: [],
      };

      setGeneratedFiles((prev) => [newFile, ...prev]);
      toast({ title: 'IaC Generated', description: `Generated ${newFile.name}` });

      const blob = new Blob([sanitized], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    } catch (err: unknown) {
      const eObj = err && typeof err === 'object' ? (err as Record<string, unknown>) : null;
      const msg = eObj && typeof eObj.message === 'string' ? eObj.message : String(err);
      toast({ title: 'IaC generation failed', description: msg || String(err), variant: 'destructive' });
    }
  };

  const workspaceTitle = useMemo(() => {
    if (projectTitle) return projectTitle;
    if (projectId) return `Project ${projectId.slice(0, 8)}`;
    return 'Azure Architect';
  }, [projectId, projectTitle]);

  const handleRename = async (newTitle: string) => {
    if (!projectId || !supabaseClient) {
      toast({ title: 'Rename failed', description: 'Sign in and open a project to rename it.', variant: 'destructive' });
      return;
    }
    try {
      await updateProjectTitle(supabaseClient, projectId, newTitle);
      setProjectTitle(newTitle);
      toast({ title: 'Project renamed', description: `Project title updated` });
    } catch (err) {
      console.error('Failed to rename project', err);
      toast({ title: 'Rename failed', description: 'Could not update project title', variant: 'destructive' });
    }
  };

  const handleDelete = async () => {
    if (!projectId || !supabaseClient) {
      toast({ title: 'Delete failed', description: 'Sign in and open a project to delete it.', variant: 'destructive' });
      return;
    }

    const confirmed = window.confirm('Are you sure you want to delete this project? This action cannot be undone.');
    if (!confirmed) return;

    try {
      await deleteProject(supabaseClient, projectId);
      toast({ title: 'Project deleted', description: 'Project has been removed.' });
      // clear local state and navigate back to index
      clearDiagram();
      setProjectId(undefined);
      setProjectTitle(undefined);
      navigate('/');
    } catch (err) {
      console.error('Failed to delete project', err);
      toast({ title: 'Delete failed', description: 'Could not delete project', variant: 'destructive' });
    }
  };

  return (
    <div className="h-screen flex flex-col overflow-hidden">
      <TopBar
        titleOverride={workspaceTitle}
        onChatToggle={handleChatToggle}
        isChatOpen={isChatOpen}
        onAssetsToggle={handleAssetsToggle}
        isAssetsOpen={isAssetsOpen}
        onIacToggle={handleIacToggle}
        isIacOpen={isIacOpen}
        onSave={handleSave}
        projectId={projectId}
        onRename={handleRename}
        onDelete={handleDelete}
      />
      <div className="flex-1 flex overflow-hidden" style={{ minHeight: 0 }}>
        <ServicePalette 
          isCollapsed={isServicePaletteCollapsed}
          onToggleCollapse={() => setIsServicePaletteCollapsed(!isServicePaletteCollapsed)}
          isChatOpen={isChatOpen}
          isIacOpen={isIacOpen}
        />
        <DiagramCanvas />
        <InspectorPanel 
          isCollapsed={isInspectorCollapsed}
          onToggleCollapse={() => setIsInspectorCollapsed(!isInspectorCollapsed)}
          isChatOpen={isChatOpen}
          isIacOpen={isIacOpen}
        />
        <IaCVisualization
          isOpen={isIacOpen}
          onToggle={handleIacToggle}
          files={generatedFiles}
          onGenerate={handleGenerate}
          onDownload={(file) => {
            const blob = new Blob([file.content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = file.name;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
          }}
          onDeploy={(file) => {
            setDeployingFile(file);
            setIsDeployModalOpen(true);
          }}
        />
        <AssetManager isOpen={isAssetsOpen} onToggle={handleAssetsToggle} onFileSelect={(file) => console.log('Selected file:', file)} />
        <ChatPanel
          isOpen={isChatOpen}
          onToggle={handleChatToggle}
          initialPrompt={pendingPrompt ?? undefined}
          onInitialPromptConsumed={() => setPendingPrompt(null)}
          projectId={projectId}
          onIacGenerated={persistIacArtifacts}
        />
      </div>
      <ResizableDivider 
        onResize={setFooterHeight}
        onMinimize={() => setFooterHeight(48)}
        onMaximize={() => setFooterHeight(400)}
        minHeight={48}
        maxHeight={600}
        defaultHeight={192}
      />
      <JobsDrawer
        height={footerHeight}
        files={generatedFiles}
        onDownload={(file) => {
          const blob = new Blob([file.content], { type: 'text/plain' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = file.name;
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
        }}
        onDeploy={(file) => {
          console.log('Deploy requested for file:', file.name);
          toast({ title: 'Deploy started', description: `Deploy requested for ${file.name}` });
        }}
      />
      <DeployModal
        open={isDeployModalOpen}
        onClose={() => setIsDeployModalOpen(false)}
        onConfirm={async (subscriptionId, resourceGroup, validationOnly) => {
          if (!deployingFile) {
            return;
          }
          toast({ title: 'Starting deploy', description: `Deploying ${deployingFile.name}...` });
          try {
            const resp = await createDeployment(
              resourceGroup,
              subscriptionId,
              deployingFile.content,
              deployingFile.type === 'terraform' ? 'terraform' : 'bicep',
              validationOnly
            );
            toast({ title: 'Deployment queued', description: `Deployment ${resp?.id} status: ${resp?.status}` });
          } catch (err: unknown) {
            const eObj = err && typeof err === 'object' ? (err as Record<string, unknown>) : null;
            const msg = eObj && typeof eObj.message === 'string' ? eObj.message : String(err);
            toast({ title: 'Deployment failed', description: msg || String(err), variant: 'destructive' });
          }
        }}
      />
    </div>
  );
};

export default Workspace;
